{"filter":false,"title":"skrollr.js","tooltip":"/js/skrollr.js","undoManager":{"mark":0,"position":0,"stack":[[{"group":"doc","deltas":[{"action":"insertText","range":{"start":{"row":0,"column":0},"end":{"row":0,"column":3}},"text":"/*!"},{"action":"insertText","range":{"start":{"row":0,"column":3},"end":{"row":1,"column":0}},"text":"\n"},{"action":"insertLines","range":{"start":{"row":1,"column":0},"end":{"row":1771,"column":0}},"lines":[" * skrollr core"," *"," * Alexander Prinzhorn - https://github.com/Prinzhorn/skrollr"," *"," * Free to use under terms of MIT license"," */","(function(window, document, undefined) {","\t'use strict';","","\t/*","\t * Global api.","\t */","\tvar skrollr = {","\t\tget: function() {","\t\t\treturn _instance;","\t\t},","\t\t//Main entry point.","\t\tinit: function(options) {","\t\t\treturn _instance || new Skrollr(options);","\t\t},","\t\tVERSION: '0.6.26'","\t};","","\t//Minify optimization.","\tvar hasProp = Object.prototype.hasOwnProperty;","\tvar Math = window.Math;","\tvar getStyle = window.getComputedStyle;","","\t//They will be filled when skrollr gets initialized.","\tvar documentElement;","\tvar body;","","\tvar EVENT_TOUCHSTART = 'touchstart';","\tvar EVENT_TOUCHMOVE = 'touchmove';","\tvar EVENT_TOUCHCANCEL = 'touchcancel';","\tvar EVENT_TOUCHEND = 'touchend';","","\tvar SKROLLABLE_CLASS = 'skrollable';","\tvar SKROLLABLE_BEFORE_CLASS = SKROLLABLE_CLASS + '-before';","\tvar SKROLLABLE_BETWEEN_CLASS = SKROLLABLE_CLASS + '-between';","\tvar SKROLLABLE_AFTER_CLASS = SKROLLABLE_CLASS + '-after';","","\tvar SKROLLR_CLASS = 'skrollr';","\tvar NO_SKROLLR_CLASS = 'no-' + SKROLLR_CLASS;","\tvar SKROLLR_DESKTOP_CLASS = SKROLLR_CLASS + '-desktop';","\tvar SKROLLR_MOBILE_CLASS = SKROLLR_CLASS + '-mobile';","","\tvar DEFAULT_EASING = 'linear';","\tvar DEFAULT_DURATION = 1000;//ms","\tvar DEFAULT_MOBILE_DECELERATION = 0.004;//pixel/msÂ²","","\tvar DEFAULT_SMOOTH_SCROLLING_DURATION = 200;//ms","","\tvar ANCHOR_START = 'start';","\tvar ANCHOR_END = 'end';","\tvar ANCHOR_CENTER = 'center';","\tvar ANCHOR_BOTTOM = 'bottom';","","\t//The property which will be added to the DOM element to hold the ID of the skrollable.","\tvar SKROLLABLE_ID_DOM_PROPERTY = '___skrollable_id';","","\tvar rxTouchIgnoreTags = /^(?:input|textarea|button|select)$/i;","","\tvar rxTrim = /^\\s+|\\s+$/g;","","\t//Find all data-attributes. data-[_constant]-[offset]-[anchor]-[anchor].","\tvar rxKeyframeAttribute = /^data(?:-(_\\w+))?(?:-?(-?\\d*\\.?\\d+p?))?(?:-?(start|end|top|center|bottom))?(?:-?(top|center|bottom))?$/;","","\tvar rxPropValue = /\\s*(@?[\\w\\-\\[\\]]+)\\s*:\\s*(.+?)\\s*(?:;|$)/gi;","","\t//Easing function names follow the property in square brackets.","\tvar rxPropEasing = /^(@?[a-z\\-]+)\\[(\\w+)\\]$/;","","\tvar rxCamelCase = /-([a-z0-9_])/g;","\tvar rxCamelCaseFn = function(str, letter) {","\t\treturn letter.toUpperCase();","\t};","","\t//Numeric values with optional sign.","\tvar rxNumericValue = /[\\-+]?[\\d]*\\.?[\\d]+/g;","","\t//Used to replace occurences of {?} with a number.","\tvar rxInterpolateString = /\\{\\?\\}/g;","","\t//Finds rgb(a) colors, which don't use the percentage notation.","\tvar rxRGBAIntegerColor = /rgba?\\(\\s*-?\\d+\\s*,\\s*-?\\d+\\s*,\\s*-?\\d+/g;","","\t//Finds all gradients.","\tvar rxGradient = /[a-z\\-]+-gradient/g;","","\t//Vendor prefix. Will be set once skrollr gets initialized.","\tvar theCSSPrefix = '';","\tvar theDashedCSSPrefix = '';","","\t//Will be called once (when skrollr gets initialized).","\tvar detectCSSPrefix = function() {","\t\t//Only relevant prefixes. May be extended.","\t\t//Could be dangerous if there will ever be a CSS property which actually starts with \"ms\". Don't hope so.","\t\tvar rxPrefixes = /^(?:O|Moz|webkit|ms)|(?:-(?:o|moz|webkit|ms)-)/;","","\t\t//Detect prefix for current browser by finding the first property using a prefix.","\t\tif(!getStyle) {","\t\t\treturn;","\t\t}","","\t\tvar style = getStyle(body, null);","","\t\tfor(var k in style) {","\t\t\t//We check the key and if the key is a number, we check the value as well, because safari's getComputedStyle returns some weird array-like thingy.","\t\t\ttheCSSPrefix = (k.match(rxPrefixes) || (+k == k && style[k].match(rxPrefixes)));","","\t\t\tif(theCSSPrefix) {","\t\t\t\tbreak;","\t\t\t}","\t\t}","","\t\t//Did we even detect a prefix?","\t\tif(!theCSSPrefix) {","\t\t\ttheCSSPrefix = theDashedCSSPrefix = '';","","\t\t\treturn;","\t\t}","","\t\ttheCSSPrefix = theCSSPrefix[0];","","\t\t//We could have detected either a dashed prefix or this camelCaseish-inconsistent stuff.","\t\tif(theCSSPrefix.slice(0,1) === '-') {","\t\t\ttheDashedCSSPrefix = theCSSPrefix;","","\t\t\t//There's no logic behind these. Need a look up.","\t\t\ttheCSSPrefix = ({","\t\t\t\t'-webkit-': 'webkit',","\t\t\t\t'-moz-': 'Moz',","\t\t\t\t'-ms-': 'ms',","\t\t\t\t'-o-': 'O'","\t\t\t})[theCSSPrefix];","\t\t} else {","\t\t\ttheDashedCSSPrefix = '-' + theCSSPrefix.toLowerCase() + '-';","\t\t}","\t};","","\tvar polyfillRAF = function() {","\t\tvar requestAnimFrame = window.requestAnimationFrame || window[theCSSPrefix.toLowerCase() + 'RequestAnimationFrame'];","","\t\tvar lastTime = _now();","","\t\tif(_isMobile || !requestAnimFrame) {","\t\t\trequestAnimFrame = function(callback) {","\t\t\t\t//How long did it take to render?","\t\t\t\tvar deltaTime = _now() - lastTime;","\t\t\t\tvar delay = Math.max(0, 1000 / 60 - deltaTime);","","\t\t\t\treturn window.setTimeout(function() {","\t\t\t\t\tlastTime = _now();","\t\t\t\t\tcallback();","\t\t\t\t}, delay);","\t\t\t};","\t\t}","","\t\treturn requestAnimFrame;","\t};","","\tvar polyfillCAF = function() {","\t\tvar cancelAnimFrame = window.cancelAnimationFrame || window[theCSSPrefix.toLowerCase() + 'CancelAnimationFrame'];","","\t\tif(_isMobile || !cancelAnimFrame) {","\t\t\tcancelAnimFrame = function(timeout) {","\t\t\t\treturn window.clearTimeout(timeout);","\t\t\t};","\t\t}","","\t\treturn cancelAnimFrame;","\t};","","\t//Built-in easing functions.","\tvar easings = {","\t\tbegin: function() {","\t\t\treturn 0;","\t\t},","\t\tend: function() {","\t\t\treturn 1;","\t\t},","\t\tlinear: function(p) {","\t\t\treturn p;","\t\t},","\t\tquadratic: function(p) {","\t\t\treturn p * p;","\t\t},","\t\tcubic: function(p) {","\t\t\treturn p * p * p;","\t\t},","\t\tswing: function(p) {","\t\t\treturn (-Math.cos(p * Math.PI) / 2) + 0.5;","\t\t},","\t\tsqrt: function(p) {","\t\t\treturn Math.sqrt(p);","\t\t},","\t\toutCubic: function(p) {","\t\t\treturn (Math.pow((p - 1), 3) + 1);","\t\t},","\t\t//see https://www.desmos.com/calculator/tbr20s8vd2 for how I did this","\t\tbounce: function(p) {","\t\t\tvar a;","","\t\t\tif(p <= 0.5083) {","\t\t\t\ta = 3;","\t\t\t} else if(p <= 0.8489) {","\t\t\t\ta = 9;","\t\t\t} else if(p <= 0.96208) {","\t\t\t\ta = 27;","\t\t\t} else if(p <= 0.99981) {","\t\t\t\ta = 91;","\t\t\t} else {","\t\t\t\treturn 1;","\t\t\t}","","\t\t\treturn 1 - Math.abs(3 * Math.cos(p * a * 1.028) / a);","\t\t}","\t};","","\t/**","\t * Constructor.","\t */","\tfunction Skrollr(options) {","\t\tdocumentElement = document.documentElement;","\t\tbody = document.body;","","\t\tdetectCSSPrefix();","","\t\t_instance = this;","","\t\toptions = options || {};","","\t\t_constants = options.constants || {};","","\t\t//We allow defining custom easings or overwrite existing.","\t\tif(options.easing) {","\t\t\tfor(var e in options.easing) {","\t\t\t\teasings[e] = options.easing[e];","\t\t\t}","\t\t}","","\t\t_edgeStrategy = options.edgeStrategy || 'set';","","\t\t_listeners = {","\t\t\t//Function to be called right before rendering.","\t\t\tbeforerender: options.beforerender,","","\t\t\t//Function to be called right after finishing rendering.","\t\t\trender: options.render,","","\t\t\t//Function to be called whenever an element with the `data-emit-events` attribute passes a keyframe.","\t\t\tkeyframe: options.keyframe","\t\t};","","\t\t//forceHeight is true by default","\t\t_forceHeight = options.forceHeight !== false;","","\t\tif(_forceHeight) {","\t\t\t_scale = options.scale || 1;","\t\t}","","\t\t_mobileDeceleration = options.mobileDeceleration || DEFAULT_MOBILE_DECELERATION;","","\t\t_smoothScrollingEnabled = options.smoothScrolling !== false;","\t\t_smoothScrollingDuration = options.smoothScrollingDuration || DEFAULT_SMOOTH_SCROLLING_DURATION;","","\t\t//Dummy object. Will be overwritten in the _render method when smooth scrolling is calculated.","\t\t_smoothScrolling = {","\t\t\ttargetTop: _instance.getScrollTop()","\t\t};","","\t\t//A custom check function may be passed.","\t\t_isMobile = ((options.mobileCheck || function() {","\t\t\treturn (/Android|iPhone|iPad|iPod|BlackBerry/i).test(navigator.userAgent || navigator.vendor || window.opera);","\t\t})());","","\t\tif(_isMobile) {","\t\t\t_skrollrBody = document.getElementById('skrollr-body');","","\t\t\t//Detect 3d transform if there's a skrollr-body (only needed for #skrollr-body).","\t\t\tif(_skrollrBody) {","\t\t\t\t_detect3DTransforms();","\t\t\t}","","\t\t\t_initMobile();","\t\t\t_updateClass(documentElement, [SKROLLR_CLASS, SKROLLR_MOBILE_CLASS], [NO_SKROLLR_CLASS]);","\t\t} else {","\t\t\t_updateClass(documentElement, [SKROLLR_CLASS, SKROLLR_DESKTOP_CLASS], [NO_SKROLLR_CLASS]);","\t\t}","","\t\t//Triggers parsing of elements and a first reflow.","\t\t_instance.refresh();","","\t\t_addEvent(window, 'resize orientationchange', function() {","\t\t\tvar width = documentElement.clientWidth;","\t\t\tvar height = documentElement.clientHeight;","","\t\t\t//Only reflow if the size actually changed (#271).","\t\t\tif(height !== _lastViewportHeight || width !== _lastViewportWidth) {","\t\t\t\t_lastViewportHeight = height;","\t\t\t\t_lastViewportWidth = width;","","\t\t\t\t_requestReflow = true;","\t\t\t}","\t\t});","","\t\tvar requestAnimFrame = polyfillRAF();","","\t\t//Let's go.","\t\t(function animloop(){","\t\t\t_render();","\t\t\t_animFrame = requestAnimFrame(animloop);","\t\t}());","","\t\treturn _instance;","\t}","","\t/**","\t * (Re)parses some or all elements.","\t */","\tSkrollr.prototype.refresh = function(elements) {","\t\tvar elementIndex;","\t\tvar elementsLength;","\t\tvar ignoreID = false;","","\t\t//Completely reparse anything without argument.","\t\tif(elements === undefined) {","\t\t\t//Ignore that some elements may already have a skrollable ID.","\t\t\tignoreID = true;","","\t\t\t_skrollables = [];","\t\t\t_skrollableIdCounter = 0;","","\t\t\telements = document.getElementsByTagName('*');","\t\t} else if(elements.length === undefined) {","\t\t\t//We also accept a single element as parameter.","\t\t\telements = [elements];","\t\t}","","\t\telementIndex = 0;","\t\telementsLength = elements.length;","","\t\tfor(; elementIndex < elementsLength; elementIndex++) {","\t\t\tvar el = elements[elementIndex];","\t\t\tvar anchorTarget = el;","\t\t\tvar keyFrames = [];","","\t\t\t//If this particular element should be smooth scrolled.","\t\t\tvar smoothScrollThis = _smoothScrollingEnabled;","","\t\t\t//The edge strategy for this particular element.","\t\t\tvar edgeStrategy = _edgeStrategy;","","\t\t\t//If this particular element should emit keyframe events.","\t\t\tvar emitEvents = false;","","\t\t\t//If we're reseting the counter, remove any old element ids that may be hanging around.","\t\t\tif(ignoreID && SKROLLABLE_ID_DOM_PROPERTY in el) {","\t\t\t\tdelete el[SKROLLABLE_ID_DOM_PROPERTY];","\t\t\t}","","\t\t\tif(!el.attributes) {","\t\t\t\tcontinue;","\t\t\t}","","\t\t\t//Iterate over all attributes and search for key frame attributes.","\t\t\tvar attributeIndex = 0;","\t\t\tvar attributesLength = el.attributes.length;","","\t\t\tfor (; attributeIndex < attributesLength; attributeIndex++) {","\t\t\t\tvar attr = el.attributes[attributeIndex];","","\t\t\t\tif(attr.name === 'data-anchor-target') {","\t\t\t\t\tanchorTarget = document.querySelector(attr.value);","","\t\t\t\t\tif(anchorTarget === null) {","\t\t\t\t\t\tthrow 'Unable to find anchor target \"' + attr.value + '\"';","\t\t\t\t\t}","","\t\t\t\t\tcontinue;","\t\t\t\t}","","\t\t\t\t//Global smooth scrolling can be overridden by the element attribute.","\t\t\t\tif(attr.name === 'data-smooth-scrolling') {","\t\t\t\t\tsmoothScrollThis = attr.value !== 'off';","","\t\t\t\t\tcontinue;","\t\t\t\t}","","\t\t\t\t//Global edge strategy can be overridden by the element attribute.","\t\t\t\tif(attr.name === 'data-edge-strategy') {","\t\t\t\t\tedgeStrategy = attr.value;","","\t\t\t\t\tcontinue;","\t\t\t\t}","","\t\t\t\t//Is this element tagged with the `data-emit-events` attribute?","\t\t\t\tif(attr.name === 'data-emit-events') {","\t\t\t\t\temitEvents = true;","","\t\t\t\t\tcontinue;","\t\t\t\t}","","\t\t\t\tvar match = attr.name.match(rxKeyframeAttribute);","","\t\t\t\tif(match === null) {","\t\t\t\t\tcontinue;","\t\t\t\t}","","\t\t\t\tvar kf = {","\t\t\t\t\tprops: attr.value,","\t\t\t\t\t//Point back to the element as well.","\t\t\t\t\telement: el,","\t\t\t\t\t//The name of the event which this keyframe will fire, if emitEvents is","\t\t\t\t\teventType: attr.name.replace(rxCamelCase, rxCamelCaseFn)","\t\t\t\t};","","\t\t\t\tkeyFrames.push(kf);","","\t\t\t\tvar constant = match[1];","","\t\t\t\tif(constant) {","\t\t\t\t\t//Strip the underscore prefix.","\t\t\t\t\tkf.constant = constant.substr(1);","\t\t\t\t}","","\t\t\t\t//Get the key frame offset.","\t\t\t\tvar offset = match[2];","","\t\t\t\t//Is it a percentage offset?","\t\t\t\tif(/p$/.test(offset)) {","\t\t\t\t\tkf.isPercentage = true;","\t\t\t\t\tkf.offset = (offset.slice(0, -1) | 0) / 100;","\t\t\t\t} else {","\t\t\t\t\tkf.offset = (offset | 0);","\t\t\t\t}","","\t\t\t\tvar anchor1 = match[3];","","\t\t\t\t//If second anchor is not set, the first will be taken for both.","\t\t\t\tvar anchor2 = match[4] || anchor1;","","\t\t\t\t//\"absolute\" (or \"classic\") mode, where numbers mean absolute scroll offset.","\t\t\t\tif(!anchor1 || anchor1 === ANCHOR_START || anchor1 === ANCHOR_END) {","\t\t\t\t\tkf.mode = 'absolute';","","\t\t\t\t\t//data-end needs to be calculated after all key frames are known.","\t\t\t\t\tif(anchor1 === ANCHOR_END) {","\t\t\t\t\t\tkf.isEnd = true;","\t\t\t\t\t} else if(!kf.isPercentage) {","\t\t\t\t\t\t//For data-start we can already set the key frame w/o calculations.","\t\t\t\t\t\t//#59: \"scale\" options should only affect absolute mode.","\t\t\t\t\t\tkf.offset = kf.offset * _scale;","\t\t\t\t\t}","\t\t\t\t}","\t\t\t\t//\"relative\" mode, where numbers are relative to anchors.","\t\t\t\telse {","\t\t\t\t\tkf.mode = 'relative';","\t\t\t\t\tkf.anchors = [anchor1, anchor2];","\t\t\t\t}","\t\t\t}","","\t\t\t//Does this element have key frames?","\t\t\tif(!keyFrames.length) {","\t\t\t\tcontinue;","\t\t\t}","","\t\t\t//Will hold the original style and class attributes before we controlled the element (see #80).","\t\t\tvar styleAttr, classAttr;","","\t\t\tvar id;","","\t\t\tif(!ignoreID && SKROLLABLE_ID_DOM_PROPERTY in el) {","\t\t\t\t//We already have this element under control. Grab the corresponding skrollable id.","\t\t\t\tid = el[SKROLLABLE_ID_DOM_PROPERTY];","\t\t\t\tstyleAttr = _skrollables[id].styleAttr;","\t\t\t\tclassAttr = _skrollables[id].classAttr;","\t\t\t} else {","\t\t\t\t//It's an unknown element. Asign it a new skrollable id.","\t\t\t\tid = (el[SKROLLABLE_ID_DOM_PROPERTY] = _skrollableIdCounter++);","\t\t\t\tstyleAttr = el.style.cssText;","\t\t\t\tclassAttr = _getClass(el);","\t\t\t}","","\t\t\t_skrollables[id] = {","\t\t\t\telement: el,","\t\t\t\tstyleAttr: styleAttr,","\t\t\t\tclassAttr: classAttr,","\t\t\t\tanchorTarget: anchorTarget,","\t\t\t\tkeyFrames: keyFrames,","\t\t\t\tsmoothScrolling: smoothScrollThis,","\t\t\t\tedgeStrategy: edgeStrategy,","\t\t\t\temitEvents: emitEvents,","\t\t\t\tlastFrameIndex: -1","\t\t\t};","","\t\t\t_updateClass(el, [SKROLLABLE_CLASS], []);","\t\t}","","\t\t//Reflow for the first time.","\t\t_reflow();","","\t\t//Now that we got all key frame numbers right, actually parse the properties.","\t\telementIndex = 0;","\t\telementsLength = elements.length;","","\t\tfor(; elementIndex < elementsLength; elementIndex++) {","\t\t\tvar sk = _skrollables[elements[elementIndex][SKROLLABLE_ID_DOM_PROPERTY]];","","\t\t\tif(sk === undefined) {","\t\t\t\tcontinue;","\t\t\t}","","\t\t\t//Parse the property string to objects","\t\t\t_parseProps(sk);","","\t\t\t//Fill key frames with missing properties from left and right","\t\t\t_fillProps(sk);","\t\t}","","\t\treturn _instance;","\t};","","\t/**","\t * Transform \"relative\" mode to \"absolute\" mode.","\t * That is, calculate anchor position and offset of element.","\t */","\tSkrollr.prototype.relativeToAbsolute = function(element, viewportAnchor, elementAnchor) {","\t\tvar viewportHeight = documentElement.clientHeight;","\t\tvar box = element.getBoundingClientRect();","\t\tvar absolute = box.top;","","\t\t//#100: IE doesn't supply \"height\" with getBoundingClientRect.","\t\tvar boxHeight = box.bottom - box.top;","","\t\tif(viewportAnchor === ANCHOR_BOTTOM) {","\t\t\tabsolute -= viewportHeight;","\t\t} else if(viewportAnchor === ANCHOR_CENTER) {","\t\t\tabsolute -= viewportHeight / 2;","\t\t}","","\t\tif(elementAnchor === ANCHOR_BOTTOM) {","\t\t\tabsolute += boxHeight;","\t\t} else if(elementAnchor === ANCHOR_CENTER) {","\t\t\tabsolute += boxHeight / 2;","\t\t}","","\t\t//Compensate scrolling since getBoundingClientRect is relative to viewport.","\t\tabsolute += _instance.getScrollTop();","","\t\treturn (absolute + 0.5) | 0;","\t};","","\t/**","\t * Animates scroll top to new position.","\t */","\tSkrollr.prototype.animateTo = function(top, options) {","\t\toptions = options || {};","","\t\tvar now = _now();","\t\tvar scrollTop = _instance.getScrollTop();","","\t\t//Setting this to a new value will automatically cause the current animation to stop, if any.","\t\t_scrollAnimation = {","\t\t\tstartTop: scrollTop,","\t\t\ttopDiff: top - scrollTop,","\t\t\ttargetTop: top,","\t\t\tduration: options.duration || DEFAULT_DURATION,","\t\t\tstartTime: now,","\t\t\tendTime: now + (options.duration || DEFAULT_DURATION),","\t\t\teasing: easings[options.easing || DEFAULT_EASING],","\t\t\tdone: options.done","\t\t};","","\t\t//Don't queue the animation if there's nothing to animate.","\t\tif(!_scrollAnimation.topDiff) {","\t\t\tif(_scrollAnimation.done) {","\t\t\t\t_scrollAnimation.done.call(_instance, false);","\t\t\t}","","\t\t\t_scrollAnimation = undefined;","\t\t}","","\t\treturn _instance;","\t};","","\t/**","\t * Stops animateTo animation.","\t */","\tSkrollr.prototype.stopAnimateTo = function() {","\t\tif(_scrollAnimation && _scrollAnimation.done) {","\t\t\t_scrollAnimation.done.call(_instance, true);","\t\t}","","\t\t_scrollAnimation = undefined;","\t};","","\t/**","\t * Returns if an animation caused by animateTo is currently running.","\t */","\tSkrollr.prototype.isAnimatingTo = function() {","\t\treturn !!_scrollAnimation;","\t};","","\tSkrollr.prototype.isMobile = function() {","\t\treturn _isMobile;","\t};","","\tSkrollr.prototype.setScrollTop = function(top, force) {","\t\t_forceRender = (force === true);","","\t\tif(_isMobile) {","\t\t\t_mobileOffset = Math.min(Math.max(top, 0), _maxKeyFrame);","\t\t} else {","\t\t\twindow.scrollTo(0, top);","\t\t}","","\t\treturn _instance;","\t};","","\tSkrollr.prototype.getScrollTop = function() {","\t\tif(_isMobile) {","\t\t\treturn _mobileOffset;","\t\t} else {","\t\t\treturn window.pageYOffset || documentElement.scrollTop || body.scrollTop || 0;","\t\t}","\t};","","\tSkrollr.prototype.getMaxScrollTop = function() {","\t\treturn _maxKeyFrame;","\t};","","\tSkrollr.prototype.on = function(name, fn) {","\t\t_listeners[name] = fn;","","\t\treturn _instance;","\t};","","\tSkrollr.prototype.off = function(name) {","\t\tdelete _listeners[name];","","\t\treturn _instance;","\t};","","\tSkrollr.prototype.destroy = function() {","\t\tvar cancelAnimFrame = polyfillCAF();","\t\tcancelAnimFrame(_animFrame);","\t\t_removeAllEvents();","","\t\t_updateClass(documentElement, [NO_SKROLLR_CLASS], [SKROLLR_CLASS, SKROLLR_DESKTOP_CLASS, SKROLLR_MOBILE_CLASS]);","","\t\tvar skrollableIndex = 0;","\t\tvar skrollablesLength = _skrollables.length;","","\t\tfor(; skrollableIndex < skrollablesLength; skrollableIndex++) {","\t\t\t_reset(_skrollables[skrollableIndex].element);","\t\t}","","\t\tdocumentElement.style.overflow = body.style.overflow = '';","\t\tdocumentElement.style.height = body.style.height = '';","","\t\tif(_skrollrBody) {","\t\t\tskrollr.setStyle(_skrollrBody, 'transform', 'none');","\t\t}","","\t\t_instance = undefined;","\t\t_skrollrBody = undefined;","\t\t_listeners = undefined;","\t\t_forceHeight = undefined;","\t\t_maxKeyFrame = 0;","\t\t_scale = 1;","\t\t_constants = undefined;","\t\t_mobileDeceleration = undefined;","\t\t_direction = 'down';","\t\t_lastTop = -1;","\t\t_lastViewportWidth = 0;","\t\t_lastViewportHeight = 0;","\t\t_requestReflow = false;","\t\t_scrollAnimation = undefined;","\t\t_smoothScrollingEnabled = undefined;","\t\t_smoothScrollingDuration = undefined;","\t\t_smoothScrolling = undefined;","\t\t_forceRender = undefined;","\t\t_skrollableIdCounter = 0;","\t\t_edgeStrategy = undefined;","\t\t_isMobile = false;","\t\t_mobileOffset = 0;","\t\t_translateZ = undefined;","\t};","","\t/*","\t\tPrivate methods.","\t*/","","\tvar _initMobile = function() {","\t\tvar initialElement;","\t\tvar initialTouchY;","\t\tvar initialTouchX;","\t\tvar currentElement;","\t\tvar currentTouchY;","\t\tvar currentTouchX;","\t\tvar lastTouchY;","\t\tvar deltaY;","","\t\tvar initialTouchTime;","\t\tvar currentTouchTime;","\t\tvar lastTouchTime;","\t\tvar deltaTime;","","\t\t_addEvent(documentElement, [EVENT_TOUCHSTART, EVENT_TOUCHMOVE, EVENT_TOUCHCANCEL, EVENT_TOUCHEND].join(' '), function(e) {","\t\t\tvar touch = e.changedTouches[0];","","\t\t\tcurrentElement = e.target;","","\t\t\t//We don't want text nodes.","\t\t\twhile(currentElement.nodeType === 3) {","\t\t\t\tcurrentElement = currentElement.parentNode;","\t\t\t}","","\t\t\tcurrentTouchY = touch.clientY;","\t\t\tcurrentTouchX = touch.clientX;","\t\t\tcurrentTouchTime = e.timeStamp;","","\t\t\tif(!rxTouchIgnoreTags.test(currentElement.tagName)) {","\t\t\t\te.preventDefault();","\t\t\t}","","\t\t\tswitch(e.type) {","\t\t\t\tcase EVENT_TOUCHSTART:","\t\t\t\t\t//The last element we tapped on.","\t\t\t\t\tif(initialElement) {","\t\t\t\t\t\tinitialElement.blur();","\t\t\t\t\t}","","\t\t\t\t\t_instance.stopAnimateTo();","","\t\t\t\t\tinitialElement = currentElement;","","\t\t\t\t\tinitialTouchY = lastTouchY = currentTouchY;","\t\t\t\t\tinitialTouchX = currentTouchX;","\t\t\t\t\tinitialTouchTime = currentTouchTime;","","\t\t\t\t\tbreak;","\t\t\t\tcase EVENT_TOUCHMOVE:","\t\t\t\t\t//Prevent default event on touchIgnore elements in case they don't have focus yet.","\t\t\t\t\tif(rxTouchIgnoreTags.test(currentElement.tagName) && document.activeElement !== currentElement) {","\t\t\t\t\t\te.preventDefault();","\t\t\t\t\t}","","\t\t\t\t\tdeltaY = currentTouchY - lastTouchY;","\t\t\t\t\tdeltaTime = currentTouchTime - lastTouchTime;","","\t\t\t\t\t_instance.setScrollTop(_mobileOffset - deltaY, true);","","\t\t\t\t\tlastTouchY = currentTouchY;","\t\t\t\t\tlastTouchTime = currentTouchTime;","\t\t\t\t\tbreak;","\t\t\t\tdefault:","\t\t\t\tcase EVENT_TOUCHCANCEL:","\t\t\t\tcase EVENT_TOUCHEND:","\t\t\t\t\tvar distanceY = initialTouchY - currentTouchY;","\t\t\t\t\tvar distanceX = initialTouchX - currentTouchX;","\t\t\t\t\tvar distance2 = distanceX * distanceX + distanceY * distanceY;","","\t\t\t\t\t//Check if it was more like a tap (moved less than 7px).","\t\t\t\t\tif(distance2 < 49) {","\t\t\t\t\t\tif(!rxTouchIgnoreTags.test(initialElement.tagName)) {","\t\t\t\t\t\t\tinitialElement.focus();","","\t\t\t\t\t\t\t//It was a tap, click the element.","\t\t\t\t\t\t\tvar clickEvent = document.createEvent('MouseEvents');","\t\t\t\t\t\t\tclickEvent.initMouseEvent('click', true, true, e.view, 1, touch.screenX, touch.screenY, touch.clientX, touch.clientY, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, 0, null);","\t\t\t\t\t\t\tinitialElement.dispatchEvent(clickEvent);","\t\t\t\t\t\t}","","\t\t\t\t\t\treturn;","\t\t\t\t\t}","","\t\t\t\t\tinitialElement = undefined;","","\t\t\t\t\tvar speed = deltaY / deltaTime;","","\t\t\t\t\t//Cap speed at 3 pixel/ms.","\t\t\t\t\tspeed = Math.max(Math.min(speed, 3), -3);","","\t\t\t\t\tvar duration = Math.abs(speed / _mobileDeceleration);","\t\t\t\t\tvar targetOffset = speed * duration + 0.5 * _mobileDeceleration * duration * duration;","\t\t\t\t\tvar targetTop = _instance.getScrollTop() - targetOffset;","","\t\t\t\t\t//Relative duration change for when scrolling above bounds.","\t\t\t\t\tvar targetRatio = 0;","","\t\t\t\t\t//Change duration proportionally when scrolling would leave bounds.","\t\t\t\t\tif(targetTop > _maxKeyFrame) {","\t\t\t\t\t\ttargetRatio = (_maxKeyFrame - targetTop) / targetOffset;","","\t\t\t\t\t\ttargetTop = _maxKeyFrame;","\t\t\t\t\t} else if(targetTop < 0) {","\t\t\t\t\t\ttargetRatio = -targetTop / targetOffset;","","\t\t\t\t\t\ttargetTop = 0;","\t\t\t\t\t}","","\t\t\t\t\tduration = duration * (1 - targetRatio);","","\t\t\t\t\t_instance.animateTo((targetTop + 0.5) | 0, {easing: 'outCubic', duration: duration});","\t\t\t\t\tbreak;","\t\t\t}","\t\t});","","\t\t//Just in case there has already been some native scrolling, reset it.","\t\twindow.scrollTo(0, 0);","\t\tdocumentElement.style.overflow = body.style.overflow = 'hidden';","\t};","","\t/**","\t * Updates key frames which depend on others / need to be updated on resize.","\t * That is \"end\" in \"absolute\" mode and all key frames in \"relative\" mode.","\t * Also handles constants, because they may change on resize.","\t */","\tvar _updateDependentKeyFrames = function() {","\t\tvar viewportHeight = documentElement.clientHeight;","\t\tvar processedConstants = _processConstants();","\t\tvar skrollable;","\t\tvar element;","\t\tvar anchorTarget;","\t\tvar keyFrames;","\t\tvar keyFrameIndex;","\t\tvar keyFramesLength;","\t\tvar kf;","\t\tvar skrollableIndex;","\t\tvar skrollablesLength;","\t\tvar offset;","\t\tvar constantValue;","","\t\t//First process all relative-mode elements and find the max key frame.","\t\tskrollableIndex = 0;","\t\tskrollablesLength = _skrollables.length;","","\t\tfor(; skrollableIndex < skrollablesLength; skrollableIndex++) {","\t\t\tskrollable = _skrollables[skrollableIndex];","\t\t\telement = skrollable.element;","\t\t\tanchorTarget = skrollable.anchorTarget;","\t\t\tkeyFrames = skrollable.keyFrames;","","\t\t\tkeyFrameIndex = 0;","\t\t\tkeyFramesLength = keyFrames.length;","","\t\t\tfor(; keyFrameIndex < keyFramesLength; keyFrameIndex++) {","\t\t\t\tkf = keyFrames[keyFrameIndex];","","\t\t\t\toffset = kf.offset;","\t\t\t\tconstantValue = processedConstants[kf.constant] || 0;","","\t\t\t\tkf.frame = offset;","","\t\t\t\tif(kf.isPercentage) {","\t\t\t\t\t//Convert the offset to percentage of the viewport height.","\t\t\t\t\toffset = offset * viewportHeight;","","\t\t\t\t\t//Absolute + percentage mode.","\t\t\t\t\tkf.frame = offset;","\t\t\t\t}","","\t\t\t\tif(kf.mode === 'relative') {","\t\t\t\t\t_reset(element);","","\t\t\t\t\tkf.frame = _instance.relativeToAbsolute(anchorTarget, kf.anchors[0], kf.anchors[1]) - offset;","","\t\t\t\t\t_reset(element, true);","\t\t\t\t}","","\t\t\t\tkf.frame += constantValue;","","\t\t\t\t//Only search for max key frame when forceHeight is enabled.","\t\t\t\tif(_forceHeight) {","\t\t\t\t\t//Find the max key frame, but don't use one of the data-end ones for comparison.","\t\t\t\t\tif(!kf.isEnd && kf.frame > _maxKeyFrame) {","\t\t\t\t\t\t_maxKeyFrame = kf.frame;","\t\t\t\t\t}","\t\t\t\t}","\t\t\t}","\t\t}","","\t\t//#133: The document can be larger than the maxKeyFrame we found.","\t\t_maxKeyFrame = Math.max(_maxKeyFrame, _getDocumentHeight());","","\t\t//Now process all data-end keyframes.","\t\tskrollableIndex = 0;","\t\tskrollablesLength = _skrollables.length;","","\t\tfor(; skrollableIndex < skrollablesLength; skrollableIndex++) {","\t\t\tskrollable = _skrollables[skrollableIndex];","\t\t\tkeyFrames = skrollable.keyFrames;","","\t\t\tkeyFrameIndex = 0;","\t\t\tkeyFramesLength = keyFrames.length;","","\t\t\tfor(; keyFrameIndex < keyFramesLength; keyFrameIndex++) {","\t\t\t\tkf = keyFrames[keyFrameIndex];","","\t\t\t\tconstantValue = processedConstants[kf.constant] || 0;","","\t\t\t\tif(kf.isEnd) {","\t\t\t\t\tkf.frame = _maxKeyFrame - kf.offset + constantValue;","\t\t\t\t}","\t\t\t}","","\t\t\tskrollable.keyFrames.sort(_keyFrameComparator);","\t\t}","\t};","","\t/**","\t * Calculates and sets the style properties for the element at the given frame.","\t * @param fakeFrame The frame to render at when smooth scrolling is enabled.","\t * @param actualFrame The actual frame we are at.","\t */","\tvar _calcSteps = function(fakeFrame, actualFrame) {","\t\t//Iterate over all skrollables.","\t\tvar skrollableIndex = 0;","\t\tvar skrollablesLength = _skrollables.length;","","\t\tfor(; skrollableIndex < skrollablesLength; skrollableIndex++) {","\t\t\tvar skrollable = _skrollables[skrollableIndex];","\t\t\tvar element = skrollable.element;","\t\t\tvar frame = skrollable.smoothScrolling ? fakeFrame : actualFrame;","\t\t\tvar frames = skrollable.keyFrames;","\t\t\tvar framesLength = frames.length;","\t\t\tvar firstFrame = frames[0];","\t\t\tvar lastFrame = frames[frames.length - 1];","\t\t\tvar beforeFirst = frame < firstFrame.frame;","\t\t\tvar afterLast = frame > lastFrame.frame;","\t\t\tvar firstOrLastFrame = beforeFirst ? firstFrame : lastFrame;","\t\t\tvar emitEvents = skrollable.emitEvents;","\t\t\tvar lastFrameIndex = skrollable.lastFrameIndex;","\t\t\tvar key;","\t\t\tvar value;","","\t\t\t//If we are before/after the first/last frame, set the styles according to the given edge strategy.","\t\t\tif(beforeFirst || afterLast) {","\t\t\t\t//Check if we already handled this edge case last time.","\t\t\t\t//Note: using setScrollTop it's possible that we jumped from one edge to the other.","\t\t\t\tif(beforeFirst && skrollable.edge === -1 || afterLast && skrollable.edge === 1) {","\t\t\t\t\tcontinue;","\t\t\t\t}","","\t\t\t\t//Add the skrollr-before or -after class.","\t\t\t\tif(beforeFirst) {","\t\t\t\t\t_updateClass(element, [SKROLLABLE_BEFORE_CLASS], [SKROLLABLE_AFTER_CLASS, SKROLLABLE_BETWEEN_CLASS]);","","\t\t\t\t\t//This handles the special case where we exit the first keyframe.","\t\t\t\t\tif(emitEvents && lastFrameIndex > -1) {","\t\t\t\t\t\t_emitEvent(element, firstFrame.eventType, _direction);","\t\t\t\t\t\tskrollable.lastFrameIndex = -1;","\t\t\t\t\t}","\t\t\t\t} else {","\t\t\t\t\t_updateClass(element, [SKROLLABLE_AFTER_CLASS], [SKROLLABLE_BEFORE_CLASS, SKROLLABLE_BETWEEN_CLASS]);","","\t\t\t\t\t//This handles the special case where we exit the last keyframe.","\t\t\t\t\tif(emitEvents && lastFrameIndex < framesLength) {","\t\t\t\t\t\t_emitEvent(element, lastFrame.eventType, _direction);","\t\t\t\t\t\tskrollable.lastFrameIndex = framesLength;","\t\t\t\t\t}","\t\t\t\t}","","\t\t\t\t//Remember that we handled the edge case (before/after the first/last keyframe).","\t\t\t\tskrollable.edge = beforeFirst ? -1 : 1;","","\t\t\t\tswitch(skrollable.edgeStrategy) {","\t\t\t\t\tcase 'reset':","\t\t\t\t\t\t_reset(element);","\t\t\t\t\t\tcontinue;","\t\t\t\t\tcase 'ease':","\t\t\t\t\t\t//Handle this case like it would be exactly at first/last keyframe and just pass it on.","\t\t\t\t\t\tframe = firstOrLastFrame.frame;","\t\t\t\t\t\tbreak;","\t\t\t\t\tdefault:","\t\t\t\t\tcase 'set':","\t\t\t\t\t\tvar props = firstOrLastFrame.props;","","\t\t\t\t\t\tfor(key in props) {","\t\t\t\t\t\t\tif(hasProp.call(props, key)) {","\t\t\t\t\t\t\t\tvalue = _interpolateString(props[key].value);","","\t\t\t\t\t\t\t\t//Set style or attribute.","\t\t\t\t\t\t\t\tif(key.indexOf('@') === 0) {","\t\t\t\t\t\t\t\t\telement.setAttribute(key.substr(1), value);","\t\t\t\t\t\t\t\t} else {","\t\t\t\t\t\t\t\t\tskrollr.setStyle(element, key, value);","\t\t\t\t\t\t\t\t}","\t\t\t\t\t\t\t}","\t\t\t\t\t\t}","","\t\t\t\t\t\tcontinue;","\t\t\t\t}","\t\t\t} else {","\t\t\t\t//Did we handle an edge last time?","\t\t\t\tif(skrollable.edge !== 0) {","\t\t\t\t\t_updateClass(element, [SKROLLABLE_CLASS, SKROLLABLE_BETWEEN_CLASS], [SKROLLABLE_BEFORE_CLASS, SKROLLABLE_AFTER_CLASS]);","\t\t\t\t\tskrollable.edge = 0;","\t\t\t\t}","\t\t\t}","","\t\t\t//Find out between which two key frames we are right now.","\t\t\tvar keyFrameIndex = 0;","","\t\t\tfor(; keyFrameIndex < framesLength - 1; keyFrameIndex++) {","\t\t\t\tif(frame >= frames[keyFrameIndex].frame && frame <= frames[keyFrameIndex + 1].frame) {","\t\t\t\t\tvar left = frames[keyFrameIndex];","\t\t\t\t\tvar right = frames[keyFrameIndex + 1];","","\t\t\t\t\tfor(key in left.props) {","\t\t\t\t\t\tif(hasProp.call(left.props, key)) {","\t\t\t\t\t\t\tvar progress = (frame - left.frame) / (right.frame - left.frame);","","\t\t\t\t\t\t\t//Transform the current progress using the given easing function.","\t\t\t\t\t\t\tprogress = left.props[key].easing(progress);","","\t\t\t\t\t\t\t//Interpolate between the two values","\t\t\t\t\t\t\tvalue = _calcInterpolation(left.props[key].value, right.props[key].value, progress);","","\t\t\t\t\t\t\tvalue = _interpolateString(value);","","\t\t\t\t\t\t\t//Set style or attribute.","\t\t\t\t\t\t\tif(key.indexOf('@') === 0) {","\t\t\t\t\t\t\t\telement.setAttribute(key.substr(1), value);","\t\t\t\t\t\t\t} else {","\t\t\t\t\t\t\t\tskrollr.setStyle(element, key, value);","\t\t\t\t\t\t\t}","\t\t\t\t\t\t}","\t\t\t\t\t}","","\t\t\t\t\t//Are events enabled on this element?","\t\t\t\t\t//This code handles the usual cases of scrolling through different keyframes.","\t\t\t\t\t//The special cases of before first and after last keyframe are handled above.","\t\t\t\t\tif(emitEvents) {","\t\t\t\t\t\t//Did we pass a new keyframe?","\t\t\t\t\t\tif(lastFrameIndex !== keyFrameIndex) {","\t\t\t\t\t\t\tif(_direction === 'down') {","\t\t\t\t\t\t\t\t_emitEvent(element, left.eventType, _direction);","\t\t\t\t\t\t\t} else {","\t\t\t\t\t\t\t\t_emitEvent(element, right.eventType, _direction);","\t\t\t\t\t\t\t}","","\t\t\t\t\t\t\tskrollable.lastFrameIndex = keyFrameIndex;","\t\t\t\t\t\t}","\t\t\t\t\t}","","\t\t\t\t\tbreak;","\t\t\t\t}","\t\t\t}","\t\t}","\t};","","\t/**","\t * Renders all elements.","\t */","\tvar _render = function() {","\t\tif(_requestReflow) {","\t\t\t_requestReflow = false;","\t\t\t_reflow();","\t\t}","","\t\t//We may render something else than the actual scrollbar position.","\t\tvar renderTop = _instance.getScrollTop();","","\t\t//If there's an animation, which ends in current render call, call the callback after rendering.","\t\tvar afterAnimationCallback;","\t\tvar now = _now();","\t\tvar progress;","","\t\t//Before actually rendering handle the scroll animation, if any.","\t\tif(_scrollAnimation) {","\t\t\t//It's over","\t\t\tif(now >= _scrollAnimation.endTime) {","\t\t\t\trenderTop = _scrollAnimation.targetTop;","\t\t\t\tafterAnimationCallback = _scrollAnimation.done;","\t\t\t\t_scrollAnimation = undefined;","\t\t\t} else {","\t\t\t\t//Map the current progress to the new progress using given easing function.","\t\t\t\tprogress = _scrollAnimation.easing((now - _scrollAnimation.startTime) / _scrollAnimation.duration);","","\t\t\t\trenderTop = (_scrollAnimation.startTop + progress * _scrollAnimation.topDiff) | 0;","\t\t\t}","","\t\t\t_instance.setScrollTop(renderTop, true);","\t\t}","\t\t//Smooth scrolling only if there's no animation running and if we're not forcing the rendering.","\t\telse if(!_forceRender) {","\t\t\tvar smoothScrollingDiff = _smoothScrolling.targetTop - renderTop;","","\t\t\t//The user scrolled, start new smooth scrolling.","\t\t\tif(smoothScrollingDiff) {","\t\t\t\t_smoothScrolling = {","\t\t\t\t\tstartTop: _lastTop,","\t\t\t\t\ttopDiff: renderTop - _lastTop,","\t\t\t\t\ttargetTop: renderTop,","\t\t\t\t\tstartTime: _lastRenderCall,","\t\t\t\t\tendTime: _lastRenderCall + _smoothScrollingDuration","\t\t\t\t};","\t\t\t}","","\t\t\t//Interpolate the internal scroll position (not the actual scrollbar).","\t\t\tif(now <= _smoothScrolling.endTime) {","\t\t\t\t//Map the current progress to the new progress using easing function.","\t\t\t\tprogress = easings.sqrt((now - _smoothScrolling.startTime) / _smoothScrollingDuration);","","\t\t\t\trenderTop = (_smoothScrolling.startTop + progress * _smoothScrolling.topDiff) | 0;","\t\t\t}","\t\t}","","\t\t//That's were we actually \"scroll\" on mobile.","\t\tif(_isMobile && _skrollrBody) {","\t\t\t//Set the transform (\"scroll it\").","\t\t\tskrollr.setStyle(_skrollrBody, 'transform', 'translate(0, ' + -(_mobileOffset) + 'px) ' + _translateZ);","\t\t}","","\t\t//Did the scroll position even change?","\t\tif(_forceRender || _lastTop !== renderTop) {","\t\t\t//Remember in which direction are we scrolling?","\t\t\t_direction = (renderTop > _lastTop) ? 'down' : (renderTop < _lastTop ? 'up' : _direction);","","\t\t\t_forceRender = false;","","\t\t\tvar listenerParams = {","\t\t\t\tcurTop: renderTop,","\t\t\t\tlastTop: _lastTop,","\t\t\t\tmaxTop: _maxKeyFrame,","\t\t\t\tdirection: _direction","\t\t\t};","","\t\t\t//Tell the listener we are about to render.","\t\t\tvar continueRendering = _listeners.beforerender && _listeners.beforerender.call(_instance, listenerParams);","","\t\t\t//The beforerender listener function is able the cancel rendering.","\t\t\tif(continueRendering !== false) {","\t\t\t\t//Now actually interpolate all the styles.","\t\t\t\t_calcSteps(renderTop, _instance.getScrollTop());","","\t\t\t\t//Remember when we last rendered.","\t\t\t\t_lastTop = renderTop;","","\t\t\t\tif(_listeners.render) {","\t\t\t\t\t_listeners.render.call(_instance, listenerParams);","\t\t\t\t}","\t\t\t}","","\t\t\tif(afterAnimationCallback) {","\t\t\t\tafterAnimationCallback.call(_instance, false);","\t\t\t}","\t\t}","","\t\t_lastRenderCall = now;","\t};","","\t/**","\t * Parses the properties for each key frame of the given skrollable.","\t */","\tvar _parseProps = function(skrollable) {","\t\t//Iterate over all key frames","\t\tvar keyFrameIndex = 0;","\t\tvar keyFramesLength = skrollable.keyFrames.length;","","\t\tfor(; keyFrameIndex < keyFramesLength; keyFrameIndex++) {","\t\t\tvar frame = skrollable.keyFrames[keyFrameIndex];","\t\t\tvar easing;","\t\t\tvar value;","\t\t\tvar prop;","\t\t\tvar props = {};","","\t\t\tvar match;","","\t\t\twhile((match = rxPropValue.exec(frame.props)) !== null) {","\t\t\t\tprop = match[1];","\t\t\t\tvalue = match[2];","","\t\t\t\teasing = prop.match(rxPropEasing);","","\t\t\t\t//Is there an easing specified for this prop?","\t\t\t\tif(easing !== null) {","\t\t\t\t\tprop = easing[1];","\t\t\t\t\teasing = easing[2];","\t\t\t\t} else {","\t\t\t\t\teasing = DEFAULT_EASING;","\t\t\t\t}","","\t\t\t\t//Exclamation point at first position forces the value to be taken literal.","\t\t\t\tvalue = value.indexOf('!') ? _parseProp(value) : [value.slice(1)];","","\t\t\t\t//Save the prop for this key frame with his value and easing function","\t\t\t\tprops[prop] = {","\t\t\t\t\tvalue: value,","\t\t\t\t\teasing: easings[easing]","\t\t\t\t};","\t\t\t}","","\t\t\tframe.props = props;","\t\t}","\t};","","\t/**","\t * Parses a value extracting numeric values and generating a format string","\t * for later interpolation of the new values in old string.","\t *","\t * @param val The CSS value to be parsed.","\t * @return Something like [\"rgba(?%,?%, ?%,?)\", 100, 50, 0, .7]","\t * where the first element is the format string later used","\t * and all following elements are the numeric value.","\t */","\tvar _parseProp = function(val) {","\t\tvar numbers = [];","","\t\t//One special case, where floats don't work.","\t\t//We replace all occurences of rgba colors","\t\t//which don't use percentage notation with the percentage notation.","\t\trxRGBAIntegerColor.lastIndex = 0;","\t\tval = val.replace(rxRGBAIntegerColor, function(rgba) {","\t\t\treturn rgba.replace(rxNumericValue, function(n) {","\t\t\t\treturn n / 255 * 100 + '%';","\t\t\t});","\t\t});","","\t\t//Handle prefixing of \"gradient\" values.","\t\t//For now only the prefixed value will be set. Unprefixed isn't supported anyway.","\t\tif(theDashedCSSPrefix) {","\t\t\trxGradient.lastIndex = 0;","\t\t\tval = val.replace(rxGradient, function(s) {","\t\t\t\treturn theDashedCSSPrefix + s;","\t\t\t});","\t\t}","","\t\t//Now parse ANY number inside this string and create a format string.","\t\tval = val.replace(rxNumericValue, function(n) {","\t\t\tnumbers.push(+n);","\t\t\treturn '{?}';","\t\t});","","\t\t//Add the formatstring as first value.","\t\tnumbers.unshift(val);","","\t\treturn numbers;","\t};","","\t/**","\t * Fills the key frames with missing left and right hand properties.","\t * If key frame 1 has property X and key frame 2 is missing X,","\t * but key frame 3 has X again, then we need to assign X to key frame 2 too.","\t *","\t * @param sk A skrollable.","\t */","\tvar _fillProps = function(sk) {","\t\t//Will collect the properties key frame by key frame","\t\tvar propList = {};","\t\tvar keyFrameIndex;","\t\tvar keyFramesLength;","","\t\t//Iterate over all key frames from left to right","\t\tkeyFrameIndex = 0;","\t\tkeyFramesLength = sk.keyFrames.length;","","\t\tfor(; keyFrameIndex < keyFramesLength; keyFrameIndex++) {","\t\t\t_fillPropForFrame(sk.keyFrames[keyFrameIndex], propList);","\t\t}","","\t\t//Now do the same from right to fill the last gaps","","\t\tpropList = {};","","\t\t//Iterate over all key frames from right to left","\t\tkeyFrameIndex = sk.keyFrames.length - 1;","","\t\tfor(; keyFrameIndex >= 0; keyFrameIndex--) {","\t\t\t_fillPropForFrame(sk.keyFrames[keyFrameIndex], propList);","\t\t}","\t};","","\tvar _fillPropForFrame = function(frame, propList) {","\t\tvar key;","","\t\t//For each key frame iterate over all right hand properties and assign them,","\t\t//but only if the current key frame doesn't have the property by itself","\t\tfor(key in propList) {","\t\t\t//The current frame misses this property, so assign it.","\t\t\tif(!hasProp.call(frame.props, key)) {","\t\t\t\tframe.props[key] = propList[key];","\t\t\t}","\t\t}","","\t\t//Iterate over all props of the current frame and collect them","\t\tfor(key in frame.props) {","\t\t\tpropList[key] = frame.props[key];","\t\t}","\t};","","\t/**","\t * Calculates the new values for two given values array.","\t */","\tvar _calcInterpolation = function(val1, val2, progress) {","\t\tvar valueIndex;","\t\tvar val1Length = val1.length;","","\t\t//They both need to have the same length","\t\tif(val1Length !== val2.length) {","\t\t\tthrow 'Can\\'t interpolate between \"' + val1[0] + '\" and \"' + val2[0] + '\"';","\t\t}","","\t\t//Add the format string as first element.","\t\tvar interpolated = [val1[0]];","","\t\tvalueIndex = 1;","","\t\tfor(; valueIndex < val1Length; valueIndex++) {","\t\t\t//That's the line where the two numbers are actually interpolated.","\t\t\tinterpolated[valueIndex] = val1[valueIndex] + ((val2[valueIndex] - val1[valueIndex]) * progress);","\t\t}","","\t\treturn interpolated;","\t};","","\t/**","\t * Interpolates the numeric values into the format string.","\t */","\tvar _interpolateString = function(val) {","\t\tvar valueIndex = 1;","","\t\trxInterpolateString.lastIndex = 0;","","\t\treturn val[0].replace(rxInterpolateString, function() {","\t\t\treturn val[valueIndex++];","\t\t});","\t};","","\t/**","\t * Resets the class and style attribute to what it was before skrollr manipulated the element.","\t * Also remembers the values it had before reseting, in order to undo the reset.","\t */","\tvar _reset = function(elements, undo) {","\t\t//We accept a single element or an array of elements.","\t\telements = [].concat(elements);","","\t\tvar skrollable;","\t\tvar element;","\t\tvar elementsIndex = 0;","\t\tvar elementsLength = elements.length;","","\t\tfor(; elementsIndex < elementsLength; elementsIndex++) {","\t\t\telement = elements[elementsIndex];","\t\t\tskrollable = _skrollables[element[SKROLLABLE_ID_DOM_PROPERTY]];","","\t\t\t//Couldn't find the skrollable for this DOM element.","\t\t\tif(!skrollable) {","\t\t\t\tcontinue;","\t\t\t}","","\t\t\tif(undo) {","\t\t\t\t//Reset class and style to the \"dirty\" (set by skrollr) values.","\t\t\t\telement.style.cssText = skrollable.dirtyStyleAttr;","\t\t\t\t_updateClass(element, skrollable.dirtyClassAttr);","\t\t\t} else {","\t\t\t\t//Remember the \"dirty\" (set by skrollr) class and style.","\t\t\t\tskrollable.dirtyStyleAttr = element.style.cssText;","\t\t\t\tskrollable.dirtyClassAttr = _getClass(element);","","\t\t\t\t//Reset class and style to what it originally was.","\t\t\t\telement.style.cssText = skrollable.styleAttr;","\t\t\t\t_updateClass(element, skrollable.classAttr);","\t\t\t}","\t\t}","\t};","","\t/**","\t * Detects support for 3d transforms by applying it to the skrollr-body.","\t */","\tvar _detect3DTransforms = function() {","\t\t_translateZ = 'translateZ(0)';","\t\tskrollr.setStyle(_skrollrBody, 'transform', _translateZ);","","\t\tvar computedStyle = getStyle(_skrollrBody);","\t\tvar computedTransform = computedStyle.getPropertyValue('transform');","\t\tvar computedTransformWithPrefix = computedStyle.getPropertyValue(theDashedCSSPrefix + 'transform');","\t\tvar has3D = (computedTransform && computedTransform !== 'none') || (computedTransformWithPrefix && computedTransformWithPrefix !== 'none');","","\t\tif(!has3D) {","\t\t\t_translateZ = '';","\t\t}","\t};","","\t/**","\t * Set the CSS property on the given element. Sets prefixed properties as well.","\t */","\tskrollr.setStyle = function(el, prop, val) {","\t\tvar style = el.style;","","\t\t//Camel case.","\t\tprop = prop.replace(rxCamelCase, rxCamelCaseFn).replace('-', '');","","\t\t//Make sure z-index gets a <integer>.","\t\t//This is the only <integer> case we need to handle.","\t\tif(prop === 'zIndex') {","\t\t\tif(isNaN(val)) {","\t\t\t\t//If it's not a number, don't touch it.","\t\t\t\t//It could for example be \"auto\" (#351).","\t\t\t\tstyle[prop] = val;","\t\t\t} else {","\t\t\t\t//Floor the number.","\t\t\t\tstyle[prop] = '' + (val | 0);","\t\t\t}","\t\t}","\t\t//#64: \"float\" can't be set across browsers. Needs to use \"cssFloat\" for all except IE.","\t\telse if(prop === 'float') {","\t\t\tstyle.styleFloat = style.cssFloat = val;","\t\t}","\t\telse {","\t\t\t//Need try-catch for old IE.","\t\t\ttry {","\t\t\t\t//Set prefixed property if there's a prefix.","\t\t\t\tif(theCSSPrefix) {","\t\t\t\t\tstyle[theCSSPrefix + prop.slice(0,1).toUpperCase() + prop.slice(1)] = val;","\t\t\t\t}","","\t\t\t\t//Set unprefixed.","\t\t\t\tstyle[prop] = val;","\t\t\t} catch(ignore) {}","\t\t}","\t};","","\t/**","\t * Cross browser event handling.","\t */","\tvar _addEvent = skrollr.addEvent = function(element, names, callback) {","\t\tvar intermediate = function(e) {","\t\t\t//Normalize IE event stuff.","\t\t\te = e || window.event;","","\t\t\tif(!e.target) {","\t\t\t\te.target = e.srcElement;","\t\t\t}","","\t\t\tif(!e.preventDefault) {","\t\t\t\te.preventDefault = function() {","\t\t\t\t\te.returnValue = false;","\t\t\t\t\te.defaultPrevented = true;","\t\t\t\t};","\t\t\t}","","\t\t\treturn callback.call(this, e);","\t\t};","","\t\tnames = names.split(' ');","","\t\tvar name;","\t\tvar nameCounter = 0;","\t\tvar namesLength = names.length;","","\t\tfor(; nameCounter < namesLength; nameCounter++) {","\t\t\tname = names[nameCounter];","","\t\t\tif(element.addEventListener) {","\t\t\t\telement.addEventListener(name, callback, false);","\t\t\t} else {","\t\t\t\telement.attachEvent('on' + name, intermediate);","\t\t\t}","","\t\t\t//Remember the events to be able to flush them later.","\t\t\t_registeredEvents.push({","\t\t\t\telement: element,","\t\t\t\tname: name,","\t\t\t\tlistener: callback","\t\t\t});","\t\t}","\t};","","\tvar _removeEvent = skrollr.removeEvent = function(element, names, callback) {","\t\tnames = names.split(' ');","","\t\tvar nameCounter = 0;","\t\tvar namesLength = names.length;","","\t\tfor(; nameCounter < namesLength; nameCounter++) {","\t\t\tif(element.removeEventListener) {","\t\t\t\telement.removeEventListener(names[nameCounter], callback, false);","\t\t\t} else {","\t\t\t\telement.detachEvent('on' + names[nameCounter], callback);","\t\t\t}","\t\t}","\t};","","\tvar _removeAllEvents = function() {","\t\tvar eventData;","\t\tvar eventCounter = 0;","\t\tvar eventsLength = _registeredEvents.length;","","\t\tfor(; eventCounter < eventsLength; eventCounter++) {","\t\t\teventData = _registeredEvents[eventCounter];","","\t\t\t_removeEvent(eventData.element, eventData.name, eventData.listener);","\t\t}","","\t\t_registeredEvents = [];","\t};","","\tvar _emitEvent = function(element, name, direction) {","\t\tif(_listeners.keyframe) {","\t\t\t_listeners.keyframe.call(_instance, element, name, direction);","\t\t}","\t};","","\tvar _reflow = function() {","\t\tvar pos = _instance.getScrollTop();","","\t\t//Will be recalculated by _updateDependentKeyFrames.","\t\t_maxKeyFrame = 0;","","\t\tif(_forceHeight && !_isMobile) {","\t\t\t//un-\"force\" the height to not mess with the calculations in _updateDependentKeyFrames (#216).","\t\t\tbody.style.height = '';","\t\t}","","\t\t_updateDependentKeyFrames();","","\t\tif(_forceHeight && !_isMobile) {","\t\t\t//\"force\" the height.","\t\t\tbody.style.height = (_maxKeyFrame + documentElement.clientHeight) + 'px';","\t\t}","","\t\t//The scroll offset may now be larger than needed (on desktop the browser/os prevents scrolling farther than the bottom).","\t\tif(_isMobile) {","\t\t\t_instance.setScrollTop(Math.min(_instance.getScrollTop(), _maxKeyFrame));","\t\t} else {","\t\t\t//Remember and reset the scroll pos (#217).","\t\t\t_instance.setScrollTop(pos, true);","\t\t}","","\t\t_forceRender = true;","\t};","","\t/*","\t * Returns a copy of the constants object where all functions and strings have been evaluated.","\t */","\tvar _processConstants = function() {","\t\tvar viewportHeight = documentElement.clientHeight;","\t\tvar copy = {};","\t\tvar prop;","\t\tvar value;","","\t\tfor(prop in _constants) {","\t\t\tvalue = _constants[prop];","","\t\t\tif(typeof value === 'function') {","\t\t\t\tvalue = value.call(_instance);","\t\t\t}","\t\t\t//Percentage offset.","\t\t\telse if((/p$/).test(value)) {","\t\t\t\tvalue = (value.slice(0, -1) / 100) * viewportHeight;","\t\t\t}","","\t\t\tcopy[prop] = value;","\t\t}","","\t\treturn copy;","\t};","","\t/*","\t * Returns the height of the document.","\t */","\tvar _getDocumentHeight = function() {","\t\tvar skrollrBodyHeight = (_skrollrBody && _skrollrBody.offsetHeight || 0);","\t\tvar bodyHeight = Math.max(skrollrBodyHeight, body.scrollHeight, body.offsetHeight, documentElement.scrollHeight, documentElement.offsetHeight, documentElement.clientHeight);","","\t\treturn bodyHeight - documentElement.clientHeight;","\t};","","\t/**","\t * Returns a string of space separated classnames for the current element.","\t * Works with SVG as well.","\t */","\tvar _getClass = function(element) {","\t\tvar prop = 'className';","","\t\t//SVG support by using className.baseVal instead of just className.","\t\tif(window.SVGElement && element instanceof window.SVGElement) {","\t\t\telement = element[prop];","\t\t\tprop = 'baseVal';","\t\t}","","\t\treturn element[prop];","\t};","","\t/**","\t * Adds and removes a CSS classes.","\t * Works with SVG as well.","\t * add and remove are arrays of strings,","\t * or if remove is ommited add is a string and overwrites all classes.","\t */","\tvar _updateClass = function(element, add, remove) {","\t\tvar prop = 'className';","","\t\t//SVG support by using className.baseVal instead of just className.","\t\tif(window.SVGElement && element instanceof window.SVGElement) {","\t\t\telement = element[prop];","\t\t\tprop = 'baseVal';","\t\t}","","\t\t//When remove is ommited, we want to overwrite/set the classes.","\t\tif(remove === undefined) {","\t\t\telement[prop] = add;","\t\t\treturn;","\t\t}","","\t\t//Cache current classes. We will work on a string before passing back to DOM.","\t\tvar val = element[prop];","","\t\t//All classes to be removed.","\t\tvar classRemoveIndex = 0;","\t\tvar removeLength = remove.length;","","\t\tfor(; classRemoveIndex < removeLength; classRemoveIndex++) {","\t\t\tval = _untrim(val).replace(_untrim(remove[classRemoveIndex]), ' ');","\t\t}","","\t\tval = _trim(val);","","\t\t//All classes to be added.","\t\tvar classAddIndex = 0;","\t\tvar addLength = add.length;","","\t\tfor(; classAddIndex < addLength; classAddIndex++) {","\t\t\t//Only add if el not already has class.","\t\t\tif(_untrim(val).indexOf(_untrim(add[classAddIndex])) === -1) {","\t\t\t\tval += ' ' + add[classAddIndex];","\t\t\t}","\t\t}","","\t\telement[prop] = _trim(val);","\t};","","\tvar _trim = function(a) {","\t\treturn a.replace(rxTrim, '');","\t};","","\t/**","\t * Adds a space before and after the string.","\t */","\tvar _untrim = function(a) {","\t\treturn ' ' + a + ' ';","\t};","","\tvar _now = Date.now || function() {","\t\treturn +new Date();","\t};","","\tvar _keyFrameComparator = function(a, b) {","\t\treturn a.frame - b.frame;","\t};","","\t/*","\t * Private variables.","\t */","","\t//Singleton","\tvar _instance;","","\t/*","\t\tA list of all elements which should be animated associated with their the metadata.","\t\tExmaple skrollable with two key frames animating from 100px width to 20px:","","\t\tskrollable = {","\t\t\telement: <the DOM element>,","\t\t\tstyleAttr: <style attribute of the element before skrollr>,","\t\t\tclassAttr: <class attribute of the element before skrollr>,","\t\t\tkeyFrames: [","\t\t\t\t{","\t\t\t\t\tframe: 100,","\t\t\t\t\tprops: {","\t\t\t\t\t\twidth: {","\t\t\t\t\t\t\tvalue: ['{?}px', 100],","\t\t\t\t\t\t\teasing: <reference to easing function>","\t\t\t\t\t\t}","\t\t\t\t\t},","\t\t\t\t\tmode: \"absolute\"","\t\t\t\t},","\t\t\t\t{","\t\t\t\t\tframe: 200,","\t\t\t\t\tprops: {","\t\t\t\t\t\twidth: {","\t\t\t\t\t\t\tvalue: ['{?}px', 20],","\t\t\t\t\t\t\teasing: <reference to easing function>","\t\t\t\t\t\t}","\t\t\t\t\t},","\t\t\t\t\tmode: \"absolute\"","\t\t\t\t}","\t\t\t]","\t\t};","\t*/","\tvar _skrollables;","","\tvar _skrollrBody;","","\tvar _listeners;","\tvar _forceHeight;","\tvar _maxKeyFrame = 0;","","\tvar _scale = 1;","\tvar _constants;","","\tvar _mobileDeceleration;","","\t//Current direction (up/down).","\tvar _direction = 'down';","","\t//The last top offset value. Needed to determine direction.","\tvar _lastTop = -1;","","\t//The last time we called the render method (doesn't mean we rendered!).","\tvar _lastRenderCall = _now();","","\t//For detecting if it actually resized (#271).","\tvar _lastViewportWidth = 0;","\tvar _lastViewportHeight = 0;","","\tvar _requestReflow = false;","","\t//Will contain data about a running scrollbar animation, if any.","\tvar _scrollAnimation;","","\tvar _smoothScrollingEnabled;","","\tvar _smoothScrollingDuration;","","\t//Will contain settins for smooth scrolling if enabled.","\tvar _smoothScrolling;","","\t//Can be set by any operation/event to force rendering even if the scrollbar didn't move.","\tvar _forceRender;","","\t//Each skrollable gets an unique ID incremented for each skrollable.","\t//The ID is the index in the _skrollables array.","\tvar _skrollableIdCounter = 0;","","\tvar _edgeStrategy;","","","\t//Mobile specific vars. Will be stripped by UglifyJS when not in use.","\tvar _isMobile = false;","","\t//The virtual scroll offset when using mobile scrolling.","\tvar _mobileOffset = 0;","","\t//If the browser supports 3d transforms, this will be filled with 'translateZ(0)' (empty string otherwise).","\tvar _translateZ;","","\t//Will contain data about registered events by skrollr.","\tvar _registeredEvents = [];","","\t//Animation frame id returned by RequestAnimationFrame (or timeout when RAF is not supported).","\tvar _animFrame;","","\t//Expose skrollr as either a global variable or a require.js module","\tif(typeof define === 'function' && define.amd) {","\t\tdefine('skrollr', function () {","\t\t\treturn skrollr;","\t\t});","\t} else if (typeof module !== 'undefined' && module.exports) {","\t\tmodule.exports = skrollr;","\t} else {","\t\twindow.skrollr = skrollr;","\t}","","}(window, document));"]}]}]]},"ace":{"folds":[],"scrolltop":0,"scrollleft":0,"selection":{"start":{"row":0,"column":0},"end":{"row":0,"column":0},"isBackwards":true},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":0},"timestamp":1411802482476,"hash":"2b1c55f612c8752f43ebfea391912d6d04abe996"}